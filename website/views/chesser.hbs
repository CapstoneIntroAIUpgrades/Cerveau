<!-- This is the ShitVis, simply a hack to display checkers so I know the games are valid. Do not take this code seriously -->
<style>
#chesser ul { list-style-type: square; }
#chesser li { margin-left: 2em; }

#chesser {width: 1280px; height: 720px;}
#chesser .canvases {width: 720px; height: 720px; float: left;}
#chesser .canvases .ui {opacity:  0.667}
#chesser canvas {width: 720px; height: auto; position: absolute;}

#chesser .tabs {background: #333; padding: 1em 1em 1em 0.25em;}
#chesser .tabs-content {margin-top: -0.5em; background: #ccc; padding: 1em 0.5em;}
#chesser .tabs-content > div {display: none;}
#chesser .tabs-content > div.current {display: block;}
#chesser .tabs span.current {background: #ccc; color: #111;}
#chesser .tabs span {background: #666; padding: 0.5em 0.5em 0.45em 0.5em; margin: -0.4em 0.25em; cursor: pointer; color: #eee;}
#chesser .status .player:before {margin-left: 1em; margin-right: 0.125em; content: "\00a0";}
#chesser .status .current-player:before {content:"\25B6";}
#chesser .file #download-link {display: block; width: 100%;}
#chesser #turn-slider {width: 16.5em;}
#chesser #playback-speed {width: 3em;}

#chesser .infobox {float: right; height: 720px; width: 500px; background: #ccc;}
#chesser .infobox .field {display: block; margin-bottom: 0.5em;}
#chesser .infobox .field label {display: inline-block; width: 6em;}

#chesser .infobox .confirm-move {margin-top: 1em; display: none;}
#chesser .infobox .confirm-move.run-turn {display: block;}
#chesser .infobox .confirm-move .promotion-field {display: none;}
#chesser .infobox .confirm-move .promotion-field.needed {display: block;}
#chesser .infobox .confirm-move .time { font-family: monospace; width: 100%; text-align: right; }
#chesser .infobox .confirm-move .confirm {margin: 0.5em 0 1em 0;}

.white-player { background: #fafafa; color: #121212; }
.black-player { background: #121212; color: #989898; }

.player {padding: 0.25em;}

#chesser .infobox .status .moves { background: #909090; padding: 0.5em; overflow-y: scroll; max-height: 24em; }
#chesser .infobox .status .moves li span { display: inline-block; width: 4em; text-align: center; padding: 0.25em; }
#chesser .infobox .status .moves li { margin: 0.3em; list-style-type: decimal; margin-left: 3.5em; }

#chesser #inspect-tree {font-family: monospace; font-size: 1.25em; height: 40em; overflow-y: scroll; overflow-x: hidden;}
#chesser ul#inspect-tree, #chesser ul#inspect-tree ul {list-style: none;}
#chesser ul#inspect-tree > li {margin-left: 0;}
#chesser #inspect-tree li:before { content: "\25AA"; width: 1.25em; display: inline-block; }
#chesser .inspect-label:after {content: " = ";}
#chesser #inspect-tree .inspect-type-game-object:before, #chesser #inspect-tree .inspect-type-array:before, #chesser #inspect-tree .inspect-type-dictionary:before {content: "\25B8";}
#chesser #inspect-tree header {display: inline;}
#chesser #inspect-tree .inspect-type-game-object.inspecting:before, #chesser #inspect-tree .inspect-type-array.inspecting:before, #chesser #inspect-tree .inspect-type-dictionary.inspecting:before {content: "\25BE";}
#chesser .inspect-type-game-object > header, #chesser .inspect-type-array > header, #chesser .inspect-type-dictionary > header {cursor: pointer;}
#chesser #inspect-tree li.inspecting > ul {display: block;}
#chesser #inspect-tree li:not(.inspecting) > ul {display: none;}
#chesser #file-loading progress {display: inline-block; width: 16em;}

heading { font-weight: bold; font-size: 1.5em; }

</style>

<div id="chesser">
	<div class="canvases">
		<canvas class="background">
		</canvas>
		<canvas class="ui">
		</canvas>
		<canvas class="pieces">
		</canvas>
	</div>
	<div class="infobox">
		<div class="tabs">
			<span class="tab-for-status">Status</span>
			<span class="tab-for-file">File</span>
			<span class="tab-for-connection">Connection</span>
			<span class="tab-for-inspect">Inspect</span>
			<span class="tab-for-help">Help</span>
		</div>
		<div class="tabs-content">
			<div class="status">
				<div class="no-game">No game.</div>
				<div class="game">
					<div class="turn">Turn:
						<span class="currentTurn">###</span>
						<span id="turn-controls">
							<input type="range" id="turn-slider" min="0" max="1" step="1" value="0"/>
							<button id="play-pause">&#9658;</button>
							<button id="prev-turn">&laquo;</button>
							<button id="next-turn">&raquo;</button>
							<label for="playback-speed">Speed</label>
							<input type="number" id="playback-speed" min="0.00" max="1000" step="0.01"/>
						</span>
					</div>
					<div class="player player-0 white-player">White Player &quot;<span class="name">NAME</span>&quot; <span class="reason"></span></div>
					<div class="player player-1 black-player">Black Player &quot;<span class="name">NAME</span>&quot; <span class="reason"></span></div>
					<section class="confirm-move">
						<heading>Your Move</heading>
						<div class="time">###</div>
						<div class="message"></div>
						<div class="field promotion-field">
							<label for="promotion-type">Promote to:</label>
							<select id="promotion-type" name="promotion-type">
								<option value="Bishop">Bishop</option>
								<option value="Knight">Knight</option>
								<option value="Queen" selected="selected">Queen</option>
								<option value="Rook">Rook</option>
							</select>
						</div>
						<button class="confirm" disabled>Confirm</button>
					</section>
					<section class="moves">
						<heading>Moves</heading>
						<ol>
						</ol>
					</section>
				</div>
			</div>
			<div class="file">
				<div class="no-load" style="display: none;">Cannot load gamelogs when connecting to live a game.</div>
				<a id="gamelog-download" href="#" style="display: none;" download>Download Gamelog for local playback</a>
				<input type="file" id="gamelog-file" name="gamelogfile"/>
				<div id="file-loading" style="display: none;">
					Loading <progress></progress>
				</div>
				<ul class="messages">
				</ul>
			</div>
			<div class="connection">
				<form class="connect">
					<div class="field">
						<label for="server">Server</label>
						<input id="server" name="server" type="textbox" value="127.0.0.1"/>
					</div>
					<div class="field">
						<label for="port">Port</label>
						<input id="port" name="port" type="number" min="80" max="65535" value="3088"/>
					</div>
					<div class="field">
						<label for="session">Session</label>
						<input id="session" name="session" type="textbox" value="new"/>
					</div>
					<div class="field">
						<label for="spectate">Spectate</label>
						<input id="spectate" name="spectate" type="checkbox"/>
					</div>
					<div class="field">
						<label for="player-name">Player Name</label>
						<input id="player-name" name="player-name" type="textbox" value="Human"/>
					</div>
					<div class="field">
						<label></label>
						<input type="submit" value="Connect"/>
					</div>
				</form>
				<ul class="connected">
				</ul>
			</div>
			<div class="inspect">
				<div class="need-game-loaded">Load a game to inspect it.</div>
				<ul id="inspect-tree">
				</ul>
			</div>
			<div class="help">
				<p>This page, &quote;Chesser&quote;, is designed to allow you to visually see Chess games. You can choose to either connect to live games to watch or play, or playback saved game files to inspect what happened throughout the game.<p>
				<p>If you ever need to load a different game, just reload the page.</p>
				<hr/>
				<p>&quote;Chesser&quote; human interface game client/visualizer for MST's <a href="http://blog.megaminerai.com/">ACM SIG-GAME</a> and CS 5400 - Introduction To Artificial Intelligence.</p>
				<p>By Jacob Fischer. Questions and comments can be sent to <a href="mailto:siggame@mst.edu">SIG-GAME</a>.</p>
			</div>
		</div>
	</div>
</div>

<script type="text/javascript">

function clamp(num, min, max) {
	return Math.min(Math.max(num, min), max);
};

function clone(obj) {
	return $.extend(true, {}, obj);
};

function capitalizeFirstLetter(string) {
	return string.charAt(0).toUpperCase() + string.slice(1);
};

function isObject(obj) {
	return obj !== null && typeof(obj) === "object";
};

function cleanPos(obj) {
	var rank;
	var file;
	switch(typeof(obj)) {
		case "string":
			rank = obj;
			file = parseInt(obj[1]);
			break;
		case "object":
			rank = obj.rank;
			file = obj.file;
			break;
	}

	return {
		rank: rank.charCodeAt(0) - "a".charCodeAt(0),
		file: 8 - file,
	};
};

function randomFromString(seedString) {
	var hash = 0;
	for(var i = 0; i < seedString.length; i++) {
		var chr = seedString.charCodeAt(i);
		hash = ((hash << 5) - hash) + chr;
		hash |= 0; // Convert to 32bit integer
	}

	var x = Math.sin(hash) * 10000;
	return x - Math.floor(x);
};

function formatTime(date) {
	var min = date.getMinutes();
	var sec = date.getSeconds();

	return min + ":" + (sec < 10 ? "0" : "") + sec;
};

function easeInOutCubic(x, t, b, c, d) {
	if ((t/=d/2) < 1) return c/2*t*t*t + b;
	return c/2*((t-=2)*t*t + 2) + b;
};

function getUrlParameter(sParam) {
	var sPageURL = decodeURIComponent(window.location.search.substring(1)),
		sURLVariables = sPageURL.split('&'),
		sParameterName,
		i;

	for (i = 0; i < sURLVariables.length; i++) {
		sParameterName = sURLVariables[i].split('=');

		if (sParameterName[0] === sParam) {
			return sParameterName[1] === undefined ? true : sParameterName[1];
		}
	}
};



function HSLColor(h, s, l) {
	this.h = clamp(Math.round(h), 0, 360);
	this.s = clamp(Math.round(s * 100), 0, 100);
	this.l = clamp(Math.round(l * 100), 0, 100);
};

HSLColor.prototype.toString = function() {
	return "hsl(" + this.h + ", " + this.s + "%, " + this.l + "%)";
};

function Color(r, g, b, a) {
	a = a === undefined ? 1 : a;
	this.r = clamp(Math.round(r * 255), 0, 255);
	this.g = clamp(Math.round(g * 255), 0, 255);
	this.b = clamp(Math.round(b * 255), 0, 255);
	this.a = clamp(a, 0, 1);
};

Color.prototype.toString = function() {
	return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", "+ this.a +")";
};



function CanvasWrapper($canvas, width, height) {
	this.$element = $canvas;
	this.context = $canvas[0].getContext("2d");

	this._fontFamily = "sans-serif";

	this.width = width || 100;
	this.height = height || 100;
	this._attrWidth = 720;
	this._attrHeight = 720;

	this._d = this._attrHeight / this.height; // assumes height/width are the same scalar diff

	this.$element.attr("width", this._attrWidth);
	this.$element.attr("height", this._attrHeight);
};

CanvasWrapper.prototype.drawRectangle = function(color, x, y, width, height) {
	width = width || 1;
	height = height || 1;

	this.context.fillStyle = color.toString();
	this.context.fillRect(x * this._d, y * this._d, width * this._d, height * this._d);
};

CanvasWrapper.prototype.drawText = function(text, color, height, x, y) {
	this.context.font = "" + Math.floor(height * this._d) + "px " + this._fontFamily;
	this.context.fillStyle = color.toString();
	x = x || 0;
	y = y || 0;
	this.context.textBaseline = "top";
	this.context.fillText(text, x * this._d, y * this._d);
};

CanvasWrapper.prototype.fillRoundedRectangle = function(color, x, y, width, height, radius) {
	this._roundedRectangle(x, y, width, height, radius);
	this.context.fillStyle = color.toString();
	this.context.fill();
};

CanvasWrapper.prototype.strokeRoundedRectangle = function(stroke, color, x, y, width, height, radius) {
	this._roundedRectangle(x, y, width, height, radius);
	this.context.lineWidth = stroke * this._d;
	this.context.strokeStyle = color.toString();
	this.context.stroke();
};

CanvasWrapper.prototype._roundedRectangle = function(x, y, width, height, radius) {
	var ctx = this.context;

	x = this._d * x;
	y = this._d * y;
	width = this._d * width;
	height = this._d * height;
	radius = this._d * radius;

	ctx.beginPath();
	ctx.moveTo(x, y + radius);
	ctx.lineTo(x, y + height - radius);
	ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
	ctx.lineTo(x + width - radius, y + height);
	ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
	ctx.lineTo(x + width, y + radius);
	ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
	ctx.lineTo(x + radius, y);
	ctx.quadraticCurveTo(x, y, x, y + radius);
};

CanvasWrapper.prototype.clear = function() {
	this.context.clearRect(0, 0, this._attrWidth, this._attrHeight);
};



function Chesser() {
	this.$this = $("#chesser");
	this.renderingTurn = 0;
	this.renderingTurnDT = 0;
	this.playbackSpeed = 1; // num > 1.0 increase speed, numbers < 1.0 decrease speed
	var canvases = $(".canvases", this.$this).children();
	this.canvases = {};

	var self = this;
	this.$connected = $("#chesser .connected");
	var serverInput = $("#server").attr("value", window.location.hostname);
	this.$connect = $("#chesser .connect");
	this.$connect.submit(function(e) {
		e.preventDefault();
		var server = serverInput.val();
		var port = parseInt($("#port", this).val()) || undefined;
		var spectating = self.$connect.$spectate.is(":checked");
		self.connectTo(server, port, spectating, {
			playerName: self.$connect.$playerName.val(),
			requestedSession: $("#session", this).val(),
		});
		self.$connect.hide();
	});

	this.$connect.$playerName = $("#player-name", this.$connect);
	this.$connect.$spectate = $("#spectate", this.$connect)
		.on("change", function() {
			if(this.checked) {
				self.$connect.$playerName.attr("disabled", true);
			}
			else {
				self.$connect.$playerName.removeAttr("disabled");
			}
		})

	this.tabs = {};
	$(".tabs-content", this.$this).children().each(function() {
		var $content = $(this);
		var key = $content.attr("class");
		var $tab = $(".tab-for-" + key, self.$this);
		self.tabs[key] = {
			"$content": $content,
			"$tab": $tab,
		};

		$tab.on("click", function(e) {
			e.preventDefault();
			self.setCurrentTab(key);
		});
	});

	$(".game", this.tabs.status.$content).hide();

	this.tabs.status.$currentTurn = $(".currentTurn", this.tabs.status.$content);
	this.tabs.status.confirmMove = {
		"$element": $(".confirm-move", this.tabs.status.$content),
		"$button": $(".confirm-move button", this.tabs.status.$content),
		"$message": $(".confirm-move .message", this.tabs.status.$content),
		"$promotionField": $(".confirm-move .promotion-field", this.tabs.status.$content),
		"$promotionType": $(".confirm-move #promotion-type", this.tabs.status.$content),
		"$time": $(".time", this.tabs.status.$content),
	};

	this.tabs.status.$turnSlider = $("#turn-slider", this.tabs.status.$content)
	$(document).on('input', "#turn-slider", function() {
		if(self._sliderNoChange) { // slider is updating because of the interval callback, so just ignore this event, or they arn't dragging (just mousing over)
			return;
		}

		self.pause();
		self.renderingTurn = parseInt(self.tabs.status.$turnSlider.val());
		self.renderingTurnDT = 0;
		self._update();
	});

	this.tabs.status.$playPauseButton = $("#play-pause", this.tabs.status.$content).on("click", function() {
		if(self._updateInterval) {
			self.pause();
		}
		else {
			self.play();
		}
	});

	this.tabs.status.$nextTurnButton = $("#next-turn", this.tabs.status.$content).on("click", function() {
		self.pause();
		for(var i = self.renderingTurn + 1; i < self._gameStates.length - 1; i++) {
			if(self._gameStates[i]._notMove) {
				continue;
			}

			self.renderingTurn = i;
			break;
		}
		self._update();
	});

	this.tabs.status.$prevTurnButton = $("#prev-turn", this.tabs.status.$content).on("click", function() {
		self.pause();
		for(var i = self.renderingTurn - 1; i >= 0; i--) {
			if(self._gameStates[i]._notMove) {
				continue;
			}

			self.renderingTurn = i;
			break;
		}
		self._update();
	});

	this.tabs.status.$playbackSpeed = $("#playback-speed", this.tabs.status.$content).on("change", function() {
		self.playbackSpeed = parseFloat($(this).val());
	});
	this.tabs.status.$playbackSpeed.val(this.playbackSpeed);

	this.tabs.status.$moves = $(".moves ol", this.tabs.status.$content);

	// init File tab
	this.tabs.file.$messages = $(".messages", this.tabs.file.$content);
	this.tabs.file.$loading = $("#file-loading");
	this.tabs.file.$progress = $("progress", this.tabs.file.$loading);
	if(!window.File || !window.FileReader || !window.FileList || !window.Blob) {
		this.tabs.file.$messages.append($("<li>").addClass("error").html("Error: The FileRead API is not supported by this browser, and you will not be able to load local gamelogs."));
	}
	else {
		this.tabs.file.$gamelogfile = $("#gamelog-file", this.tabs.file.$content).on("change", function() {
			var reader = new FileReader();
			reader.onloadend = function() {
				self.tabs.file.$loading.show();
				self.addFileMessage("File loaded successfully.");
				try {
					var parsed = JSON.parse(reader.result);
				}
				catch(e) {
					self.addFileMessage("Error: Could not parse the gamelog file as valid JSON - '" + e.message + "'.", "error");
				}

				self.addFileMessage("File parsed as valid JSON.");
				self._gamelogLoaded(parsed);
			};

			reader.onerror = function() {
				self.addFileMessage("Error: Could not read local gamelog file.", "error");
			};

			self.addFileMessage("Reading local gamelog file.");
			reader.readAsText(this.files[0]);
		});
	}

	this.tabs.inspect.$tree = $("#inspect-tree");
	this.tabs.inspect.$needGamelog = $(".need-game-loaded", this.tabs.inspect.$content);

	this.setCurrentTab("help");

	this.tabs.status.confirmMove.$button.on("click", function(e) {
		e.preventDefault();
		self._joueur.send("run", {
			caller: {id: self._activePiece.id},
			functionName: "move",
			args: {
				rank: self._activeMove.to[0],
				file: parseInt(self._activeMove.to[1]),
				promotionType: self.tabs.status.confirmMove.$promotionType.val() || "Queen",
			},
		});
	})

	this._playerColorsTop = [
		new Color(0.4, 0.4, 0.4),
		new Color(0, 0, 0)
	];

	this._playerColorsBottom = [
		new Color(1, 1, 1),
		new Color(0.2, 0.2, 0.2)
	];

	this._pieceTextTop = {
		King: String.fromCharCode(9812),
		Queen: String.fromCharCode(9813),
		Rook: String.fromCharCode(9814),
		Bishop: String.fromCharCode(9815),
		Knight: String.fromCharCode(9816),
		Pawn: String.fromCharCode(9817),
	};

	this._pieceTextBottom = {
		King: String.fromCharCode(9818),
		Queen: String.fromCharCode(9819),
		Rook: String.fromCharCode(9820),
		Bishop: String.fromCharCode(9821),
		Knight: String.fromCharCode(9822),
		Pawn: String.fromCharCode(9823),
	};

	for(var i = 0; i < canvases.length; i++) {
		var child = $(canvases[i]);
		this.canvases[child.attr("class")] = new CanvasWrapper(child, 8, 8);
	}

	this.initPlaying();

	this._drawBackground();

	var log = getUrlParameter("log") || getUrlParameter("gamelog") || getUrlParameter("logUrl"); // logUrl to be compatible with Wyatt's visualizer url parm
	if(log) {
		this.tabs.file.$loading.show();
		this.addFileMessage("Fetching remote gamelog at '" + log + "'.");
		this.linkToGamelog(log);
		this.tabs.file.$gamelogfile.hide();
		$.ajax({
			dataType: "json",
			url: log,
			success: function(data) {
				self.addFileMessage("Remote gamelog fetched.");
				if(data.error) {
					self.addFileMessage("Fetched gamelog was an error: '" + data.error + "'.", "error");
				}
				else {
					self._gamelogLoaded(data);
				}
			},
			error: function(data) {
				self.addFileMessage("Error fetching remote gamelog.", "error");
			},
		});
	}
};

Chesser.prototype.linkToGamelog = function(link) {
	$("#gamelog-download").show().attr("href", link);
};

Chesser.prototype._colorize = function(rand) {
	var h = Math.round(rand*360);
	this._uiHighlightColor = new HSLColor(h, 0.5, 0.5);
	this._uiActiveHightlightColor = new HSLColor((h + 225)%360, 0.5, 0.5);
	this._drawBackground((h + 135)%360);
};

Chesser.prototype._drawBackground = function(h) {
	var lightOutter = h ? new HSLColor(h, 0.5, 0.575) : new Color(0.7, 0.7, 0.7);
	var darkOutter = h ? new HSLColor(h, 0.5, 0.425) : new Color(0.3, 0.3, 0.3);
	var lightInner = h ? new HSLColor(h, 0.5, 0.667) : new Color(0.8, 0.8, 0.8);
	var darkInner = h ? new HSLColor(h, 0.5, 0.333) : new Color(0.2, 0.2, 0.2);
	var borderWidth = 0.05;
	var borderRadius = 0.075;

	var canvas = this.canvases.background;
	for(var rank = 0; rank < 8; rank++) {
		for(var file = 0; file < 8; file++) {
			var dark = (rank+file)%2;
			canvas.drawRectangle(dark ? darkOutter : lightOutter, rank, file);
			canvas.fillRoundedRectangle(dark ? darkInner : lightInner, rank + borderWidth, file + borderWidth, 1 - borderWidth*2, 1 - borderWidth*2, borderRadius);
		}
	}
}

Chesser.prototype.connectTo = function(server, port, spectating, optionalArgs) {
	var self = this;
	this.playing = !spectating;
	this.tabs.file.$content.children().each(function() {
		var $child = $(this);
		$child.toggle($child.hasClass("no-load"));
	});
	this._joueur = new Joueur(server, port, spectating, optionalArgs, function(err) {
		self.updateConnection("Error connecting to " + server + ":" + port);
	});

	this._gameStates = this._joueur.gameStates; // we have no gamelog file to read gamestates from, instead the joueur client will handle fetching new gamestates as they stream in

	this.updateConnection("Attempting to connect to " + server + ":" + port);

	this._joueur.onDelta = function() {
		if(!self.isPlaying()) {
			self.play();
		}
	};

	this._joueur.onLobbied = function(data) {
		self.updateConnection("In lobby for game '" + data.gameName + "' in session '" + data.gameSession + "'.");
	};

	this._joueur.onStart = function(data) {
		self._colorize(Math.random());
		self.updateConnection("Game Started!");
		$(".game", self.tabs.status.$content).show();
		$("#turn-controls", self.tabs.status.$content).hide();
		$(".no-game", self.tabs.status.$content).hide();
		self.tabs.inspect.$needGamelog.hide();
		self.playerID = data.playerID;
		self.startTime = self.playerID ? self._gameStates[0].gameObjects[self.playerID].timeRemaining: -1;
		self.setCurrentTab("status");
	};

	this._joueur.onOver = function(data) {
		self.updateConnection("Game is over. Disconnected from server.");
		if(data.gamelogLink) {
			self.linkToGamelog(data.gamelogLink);
		}
		self.over = true;
	};

	this._joueur.onClose = function() {
		if(!self.over) {
			self.updateConnection("Connection closed unexpectedly...");
			self.setCurrentTab("connection");
		}
	};

	if(this.playing) {
		this._joueur.onOrder = function(data) {
			self._currentOrder = data;
			self._validMoves = null;
			self._joueur.send("run", {
				caller: {id: self.playerID},
				functionName: "getMoves",
				args: {},
			});
		}

		this._joueur.onRan = function(data) {
			if(!self._validMoves) {
				delete data["&LEN"];
				self._validMoves = data;

				self._runTurn();
			}
			else { // we should have just ran a 'move', so finish our turn
				self._joueur.send("finished", {
					orderIndex: self._currentOrder.index,
					returned: true,
				});

				delete this._currentOrder;
				self.playerDone();
			}
		}
	}
};

Chesser.prototype.playerDone = function() {
	this._unselectActive();
	this._uiUnlocked = false;
	this.pausePlayerTime();
	this.tabs.status.confirmMove.$element.removeClass("run-turn");
};

Chesser.prototype.updateConnection = function(str) {
	this.$connected.append($("<li>").html(str));
};

Chesser.prototype.addFileMessage = function(str, classes) {
	var $li =$("<li>").html(str);
	this.tabs.file.$messages.append($li);

	if(classes) {
		$li.addClass(classes);
	}
};

Chesser.prototype._emptyBoard = function() {
	this._board = this.board || [];
	for(var rank = 0; rank < 8; rank++) {
		this._board[rank] = this._board[rank] || [];
		for(var file = 0; file < 8; file++) {
			this._board[rank][file] = null;
		}
	}

	return this._board;
};

Chesser.prototype._updateBoard = function() {
	var current = this._gameStates[this.renderingTurn];
	var next = this._gameStates[this.renderingTurn + 1];
	var gameObjs = current.gameObjects;
	var nextGameObjs = next && next.gameObjects;
	this.canvases.pieces.clear();

	this._emptyBoard();

	var d = easeInOutCubic(0, this.renderingTurnDT, 0, 1, 1);

	for(var id in gameObjs) {
		if(gameObjs.hasOwnProperty(id)) {
			var gameObj = gameObjs[id];
			if(gameObj.gameObjectName === "Piece" && !gameObj.captured) {
				var pos = cleanPos(gameObj);
				this._board[pos.rank][pos.file] = gameObj; // for playing as a client (they should not be moving before making moves, chess is not asyncronous)

				var fadeOut = false;
				if(this.renderingTurnDT > 0 && nextGameObjs) {
					var nextGameObj = nextGameObjs[id];
					var toPos = cleanPos(nextGameObj);

					if(nextGameObj.captured) {
						fadeOut = true;
						toPos = pos; // instead of flying off to -1, -1
					}

					pos = {
						rank: pos.rank + (toPos.rank - pos.rank) * d,
						file: pos.file + (toPos.file - pos.file) * d,
					};
				}
				this.drawPiece(gameObj, pos.rank, pos.file, fadeOut ? 1 - this.renderingTurnDT : 1);
			}
		}
	}
};

Chesser.prototype._updateStatus = function() {
	var current = this._gameStates[this.renderingTurn];

	this.tabs.status.$currentTurn.html(current.currentTurn);

	for(var i = 0; i < current.players.length; i++) {
		var player = current.gameObjects[current.players[i].id];
		var $status = $(".player-" + i, this.tabs.status.$content);
		$(".name", $status).html(player.name);
		$status
			.addClass("client-" + player.clientType.toLowerCase())
			.removeClass("current-player");

		if(current.currentPlayer.id === player.id) {
			$status.addClass("current-player");
		}

		var reason = "";
		if(player.won) {
			reason = "Won! - &quot;" + player.reasonWon + "&quot;";
		}
		else if(player.lost) {
			reason = "Lost - &quot;" + player.reasonLost + "&quot;";
		}
		else if(player.inCheck) {
			reason = " - In Check!";
		}

		$(".reason", $status).html(reason);
	}

	this.tabs.status.$playPauseButton.html(this._updateInterval ? "&#10074;&#10074;" : "&#9658;"); // pause characters (two vertical bars) or play character (left arrow)

	this._updateMovesTable();
};

Chesser.prototype.drawPiece = function(piece, rank, file, alpha) {
	var canvas = this.canvases.pieces;

	var bottom = this._playerColorsBottom[piece.owner.id];
	bottom.a = alpha;
	var top = this._playerColorsTop[piece.owner.id];
	top.a = alpha;

	canvas.drawText(this._pieceTextBottom[piece.type], bottom, 1, rank, file);
	canvas.drawText(this._pieceTextTop[piece.type], top, 1, rank, file);

	bottom.a  = 1;
	top.a = 1;
};

Chesser.prototype.setCurrentTab = function(currentKey) {
	for(var key in this.tabs) {
		if(this.tabs.hasOwnProperty(key)) {
			var tab = this.tabs[key];
			tab.$tab.removeClass("current");
			tab.$content.removeClass("current");
			if(key === currentKey) {
				tab.$tab.addClass("current");
				tab.$content.addClass("current");
			}
		}
	}
};

Chesser.prototype.initPlaying = function() {
	var self = this;
	var canvas = this.canvases.pieces.$element;
	var canvasWrapper = this.canvases.pieces;
	canvas.on("mouseup", function(e) {
		var rect = canvas[0].getBoundingClientRect();
		self._onClick(canvasWrapper.width*(e.clientX - rect.left)/canvas.width(), canvasWrapper.height*(e.clientY - rect.top)/canvas.height());
	})
};

Chesser.prototype._onClick = function(x, y) {
	var rank = Math.floor(x);
	var file = Math.floor(y);
	if(this._uiUnlocked) {
		var piece = this._board[rank][file];
		if(this.playing) {
			if(this._activePiece) {
				// see if they clicked a valid move tile
				for(var i = 0; i < this._activeValidMoves.length; i++) {
					var move = this._activeValidMoves[i];
					var pos = cleanPos(move.to);
					if(pos.rank === rank && pos.file === file) {
						return this._confirmMove(move);
					}
				}

				// otherwise unselect the active piece
				this._unselectActive();
			}
			else if(piece) {
				if(piece.owner.id === this.playerID) {
					this._activePiece = piece;
					this._makeActive(piece);
				}
			}
		}
	}
};

Chesser.prototype._unselectActive = function() {
	this.canvases.ui.clear();
	this._activePiece = null;
	this._activeMove = null;
	this._activeValidMoves = null;
	this.tabs.status.confirmMove.$message.html("Select a piece to move.");
	this.tabs.status.confirmMove.$promotionField.removeClass("needed");
	this.tabs.status.confirmMove.$button.prop("disabled", true);
};

Chesser.prototype._runTurn = function() {
	this.tabs.status.confirmMove.$element.addClass("run-turn");
	this.tabs.status.confirmMove.$message.text("Select a piece to move.");
	this.tickPlayerTime();
	this._uiUnlocked = true;
};

Chesser.prototype.tickPlayerTime = function() {
	var self = this;
	var current = this._gameStates[this._gameStates.length - 1];
	var time = current.gameObjects[this.playerID].timeRemaining;
	var oneSecInNs = 1e9;
	var oneMsInNs = 1e6;

	this._playerTimeInterval = setInterval(function() {
		self.tabs.status.confirmMove.$time.html(formatTime(new Date(time/oneMsInNs)) + " / " + formatTime(new Date(self.startTime/oneMsInNs)));
		time -= oneSecInNs;
	}, 1000); // tick every second (1000ms)
};

Chesser.prototype.pausePlayerTime = function() {
	clearTimeout(this._playerTimeInterval);
	delete this._playerTimeInterval;
};

Chesser.prototype._makeActive = function(piece) {
	var moves = [];
	for(var id in this._validMoves) {
		if(this._validMoves.hasOwnProperty(id)) {
			var move = this._validMoves[id];
			if(move.from === (piece.rank + piece.file)) {
				moves.push(move);
			}
		}
	}
	this._activePiece = piece;
	this._activeValidMoves = moves;

	this._updateUI();
};

Chesser.prototype._updateUI = function() {
	var canvas = this.canvases.ui;
	canvas.clear();

	if(this._activePiece) {
		var pos = cleanPos(this._activePiece);
		canvas.strokeRoundedRectangle(0.1, this._uiActiveHightlightColor, pos.rank, pos.file, 1, 1, 0.2);
	}

	// remove duplicate position moves (pawns have 4 moves to end tiles because each move is unqiue due to 4 different promotion types)
	var moves = {};
	for(var i = 0; i < this._activeValidMoves.length; i++) {
		var validMove = this._activeValidMoves[i];
		moves[validMove.to] = moves[validMove.to] || validMove;
	}

	for(var key in moves) {
		if(moves.hasOwnProperty(key)) {
			var move = moves[key];
			var pos = cleanPos(move.to);
			var color = this._uiHighlightColor;
			if(this._activeMove && move.to === this._activeMove.to) {
				color = this._uiActiveHightlightColor;
			}

			canvas.fillRoundedRectangle(color, pos.rank, pos.file, 1, 1, 0.2);
		}
	}
};

Chesser.prototype._confirmMove = function(move) {
	var piece = this._activePiece;
	this._activeMove = move;
	this.setCurrentTab("status");
	this.tabs.status.confirmMove.$message.html("Move " + piece.type + " #" + piece.id + " from " + move.from + " to " + move.to + "?");

	if(move.flags && move.flags.indexOf("p") >= 0) { // then this move has a promotions
		this.tabs.status.confirmMove.$promotionField.addClass("needed");
	}

	this.tabs.status.confirmMove.$button.prop("disabled", false);

	this._updateUI();
};

Chesser.prototype._updateMovesTable = function() {
	var recordedWhite = false;
	var current = this._gameStates[this.renderingTurn];

	this.tabs.status.$moves.html("");
	for(var i = 0; i < current.moves.length; i++) {
		var san = current.moves[i];

		var span;
		if(recordedWhite) {
			var li = $("li:last-child", this.tabs.status.$moves);
			span = $("<span>").addClass("black-player").appendTo(li);
		}
		else {
			li = $("<li>");
			li.appendTo(this.tabs.status.$moves);

			span = $("<span>").addClass("white-player").appendTo(li);
		}

		span.html(san);
		recordedWhite = !recordedWhite;
	}
};

Chesser.prototype._gamelogLoaded = function(parsed) {
	this.updateConnection("Cannot connect to live games while playing back gamelogs.");
	this.addFileMessage("Parsing gamelog.");
	this.tabs.inspect.$needGamelog.hide();
	this.tabs.file.$progress.attr("max", parsed.deltas.length);

	this._rawGamelog = parsed;
	this._gameStates = [];

	this.tabs.file.$gamelogfile.attr("disabled", true);
	this.$connect.hide();
	$(".game", this.tabs.status.$content).show();
	$(".no-game", this.tabs.status.$content).hide();

	this._asynchParse(0);
};

Chesser.prototype._asynchParse = function(i) {
	var state = this._rawGamelog.deltas[i].game;
	var prev = this._gameStates[i - 1] || {};
	Joueur.prototype.addDelta(this._gameStates, prev, state);
	this.tabs.file.$progress.attr("value", i + 1);

	i++;
	if(i < this._rawGamelog.deltas.length) {
		var self = this;
		setTimeout(function() {
			self._asynchParse(i);
		}, 0);
	}
	else {
		this.tabs.status.$turnSlider.attr("max", this._gameStates.length - 1);

		this._colorize(randomFromString(this._rawGamelog.randomSeed));

		this.setCurrentTab("status");

		this.addFileMessage("Gamelog parsed. Playing back.");
		this.tabs.file.$loading.hide();
		this.play();
	}
};

Chesser.prototype.isPlaying = function() {
	return this._updateInterval !== undefined;
};

Chesser.prototype.play = function() {
	var self = this;
	var dt = 1/60 // update 60 times every 1 second
	this._updateInterval = window.setInterval(function() {
		var d = dt * self.playbackSpeed;

		var oldTurn = self.renderingTurn;
		if(self.getCurrentState()._notMove) {
			d = 1; // advance 1 turn, no need to animate a non-move
		}

		self.renderingTurnDT += d;

		while(self.renderingTurnDT >= 1) {
			self.renderingTurn += 1;
			self.renderingTurnDT -= 1;

			self._sliderNoChange = true;
			self.tabs.status.$turnSlider.val(self.renderingTurn);
			self._sliderNoChange = false;
		}

		if(self.renderingTurn >= self._gameStates.length) {
			self.renderingTurn = self._gameStates.length - 1;
			self.renderingTurnDT = 0;
			self.pause();
		}

		self._update(oldTurn);
	}, dt * 1000); // interval from sec to ms
};

Chesser.prototype.getCurrentState = function() {
	return this._gameStates[this.renderingTurn];
};

Chesser.prototype.pause = function() {
	if(this._updateInterval !== undefined) {
		window.clearTimeout(this._updateInterval);
		delete this._updateInterval;

		this._update();
	}
};

Chesser.prototype._update = function(oldTurn) {
	this._updateBoard();
	this._updateStatus();
	if(oldTurn !== this.renderingTurn) {
		this._updateInspect();
	}
};

Chesser.prototype._updateInspect = function() {
	var current = this.getCurrentState();

	var depth = 1;
	var $list = this.tabs.inspect.$tree.html("");

	this._updateInspectAt(current, current, depth, $list);
};

Chesser.prototype._updateInspectAt = function(current, state, depth, $list) {
	var self = this;
	var keys = [];
	for(var key in state) {
		if(state.hasOwnProperty(key) && key.charAt(0) !== "_") {
			keys.push(key);
		}
	}

	if(state !== current.gameObjects && (!Array.isArray || !Array.isArray(state))) {
		keys.sort();
	}
	else {
		keys.sort(function(idA, idB) {
			return parseInt(idA) - parseInt(idB);
		});
	}

	for(var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var stateObj = state[key];

		var objStr = stateObj;
		var objType = typeof(stateObj);
		switch(objType) {
			case "string":
				objStr = "&quot;" + objStr + "&quot;";
				break;
			case "object":
				if(stateObj.id) { // then it's a game object reference
					objType = "game-object";
					var gameObj = current.gameObjects[stateObj.id];
					if(gameObj.gameObjectName === "Player") {
						objStr = "Player &quot;" + gameObj.name + "&quot;";
					}
					else if(gameObj.gameObjectName === "Piece") {
						objStr = "Piece " + current.gameObjects[gameObj.owner.id].color + " " + gameObj.type;
					}
					else {
						objStr = gameObj.gameObjectName;
					}

					objStr += " #" + gameObj.id;
				}
				else {
					objStr = "Dictionary[" + (Object.keys ? Object.keys(stateObj).length : "?") + "]";
					objType = "dictionary";
				}
				break;
			case "boolean":
				objStr = objStr ? "true" : "false";
				break;
		}

		if(Array.isArray && Array.isArray(stateObj)) {
			objType = "array";
			objStr = "Array[" + stateObj.length + "]";
		}

		if(objType === "dictionary" || objType === "array") {

		}

		var $subList = $("<ul>");
		var $header = $("<header>")
			.append($("<span>")
				.addClass("inspect-label")
				.html(key)
			)
			.append($("<span>")
				.addClass("inspect-value")
				.html(objStr)
			);

		var $li = $("<li>")
			.attr("id", "inspect-tree-depth-" + depth + "-" + key)
			.addClass("inspect-type-" + objType)
			.append($header)
			.append($subList)
			.appendTo($list);

		if(typeof(stateObj) === "object" && objType !== "game-obj") {
			(function(current, stateObj, depth, $li, $subList) {
				$header.on("click", function(e) {
					e.stopPropagation();
					$li.toggleClass("inspecting");

					if($li.hasClass("inspecting") && $subList.html() === "") { // then we need to lazy load the sub list
						self._updateInspectAt(current, stateObj, depth + 1, $subList);
						if($subList.html() === "") { // it's still empty
							$subList.html('<li><em class="inspecting-empty">empty</em></li>');
						}
					}
				});
			})(current, stateObj, depth, $li, $subList);
		}
	}
}



function Joueur(server, port, spectating, optionalArgs, errorCallback) {
	var self = this;
	this.gameStates = [];

	server = server || "localhost";
	port = port || 3088;
	try {
		this.ws = new WebSocket("ws://" + server + ":" + port);
	}
	catch(err) {
		errorCallback && errorCallback(err);
	}

	this.ws.onopen = function() {
		self.send("play", {
			gameName: "Chess",
			requestedSession: optionalArgs.requestedSession || "*",
			spectating: spectating ? true : undefined,
			clientType: "JavaScript in Browser",
			playerName: optionalArgs.playerName || "In Browser",
		});
	};

	this.ws.onerror = function(err) {
		errorCallback && errorCallback(err);
	};

	this.ws.onmessage = function(message) {
		if(getUrlParameter("printIO")) {
			console.log("FROM SERVER <-- ", message.data);
		}

		self.received(JSON.parse(message.data));
	};

	this.ws.onclose = function() {
		self.onClose && self.onClose();
	};
};

Joueur.prototype.received = function(data) {
	var captializedEvent = capitalizeFirstLetter(data.event);

	var funct = this["_autoHandle" + captializedEvent];
	if(funct) {
		funct.call(this, data.data);
	}

	if(this["on" + captializedEvent]) {
		this["on" + captializedEvent](data.data);
	}
};

Joueur.prototype._autoHandleOver = function(data) {
	this.ws.close();
};

Joueur.prototype._autoHandleDelta = function(data) {
	Joueur.prototype.addDelta(this.gameStates, this.gameStates[this.gameStates.length - 1], data);
};

Joueur.prototype.addDelta = function(states, prev, delta) {
	prev = prev || {};
	var newState = Joueur.prototype.mergeDelta(clone(prev), delta);
	newState._notMove = false;

	// see if a chess piece moved from prev to newState
	for(var id in newState.gameObjects) {
		if(newState.gameObjects.hasOwnProperty(id)) {
			if(!prev.gameObjects || !prev.gameObjects[id]) {
				continue;
			}

			if(newState.gameObjects[id].rank !== prev.gameObjects[id].rank || newState.gameObjects[id].file !== prev.gameObjects[id].file) {
				newState._notMove = true;
				break;
			}
		};
	}

	states.push(newState);
};

Joueur.prototype.mergeDelta = function(state, delta) {
	var deltaLength = delta["&LEN"];

	if(deltaLength !== undefined) { // then this part in the state is an array
		delete delta["&LEN"]; // we don't want to copy this key/value over to the state, it was just to signify it is an array
		while(state.length > deltaLength) { // pop elements off the array until the array is short enough. an increase in array size will be added below as arrays resize when keys larger are set
			state.pop();
		}
	}

	for(var key in delta) {
		if(delta.hasOwnProperty(key)) {
			var d = delta[key];
			if(d === "&RM") {
				delete state[key];
			}
			else if(isObject(d) && isObject(state[key])) {
				Joueur.prototype.mergeDelta(state[key], d); // static use in case this function is called statically
			}
			else {
				if(isObject(d)) {
					var newState = (d["&LEN"] === undefined ? {} : []);
					state[key] = Joueur.prototype.mergeDelta(newState, d);
				}
				else {
					state[key] = d;
				}
			}
		}
	}

	return state;
};

Joueur.prototype.send = function(eventName, data) {
	// NOTE: this does not serialize game objects, so don't be sending cycles like other joueurs
	var str = JSON.stringify({
		event: eventName,
		sentTime: (new Date).getTime(),
		data: data,
	});

	if(getUrlParameter("printIO")) {
		console.log("TO SERVER --> ", str);
	}

	this.ws.send(str);
}

var chesser = new Chesser();
$("#main").css("max-width", "1280px");



</script>