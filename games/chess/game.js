// Generated by Creer at 03:35AM on December 16, 2015 UTC, git hash: '1b69e788060071d644dd7b8745dca107577844e1'

var Class = require(__basedir + "/utilities/class");
var serializer = require(__basedir + "/gameplay/serializer");
var log = require(__basedir + "/gameplay/log");
var TwoPlayerGame = require(__basedir + "/gameplay/shared/twoPlayerGame");
var TurnBasedGame = require(__basedir + "/gameplay/shared/turnBasedGame");

//<<-- Creer-Merge: requires -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

var Chess = require("chess.js").Chess; // a very popular chess framework we will use to run all chess logic. This Game is basically an interface to chess.js

//<<-- /Creer-Merge: requires -->>

// @class Game: The traditional 8x8 chess board with pieces.
var Game = Class(TwoPlayerGame, TurnBasedGame, {
    /**
     * Initializes Games.
     *
     * @param {Object} data - a simple mapping passsed in to the constructor with whatever you sent with it. GameSettings are in here by key/value as well.
     */
    init: function(data) {
        TurnBasedGame.init.apply(this, arguments);
        TwoPlayerGame.init.apply(this, arguments);

        /**
         *  The list of moves in standard algebraic notation (SAN).
         *
         * @type {list.<string>}
         */
        this._addProperty("moves", serializer.defaultArray(data.moves));

        /**
         * All the uncaptured pieces in the game.
         *
         * @type {list.<Piece>}
         */
        this._addProperty("pieces", serializer.defaultArray(data.pieces));

        /**
         * How many turns until the game ends because no pawn has moved and no piece has been taken.
         *
         * @type {number}
         */
        this._addProperty("turnsToDraw", serializer.defaultInteger(data.turnsToDraw));


        //<<-- Creer-Merge: init -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.chess = new Chess();
        this.maxTurns = 6000; // longest possible game without stalemate is 5,950
        this.turnsToDraw = 100; // 50 move rule, 50 moves are two complete turns, so 100 turns in total.

        //<<-- /Creer-Merge: init -->>
    },

    name: "Chess",
    webserverID: "MegaMinerAI-##-Chess",


    /**
     * This is called when the game begins, once players are connected and ready to play, and game objects have been initialized. Anything in init() may not have the appropriate game objects created yet..
     */
    begin: function() {
        TurnBasedGame.begin.apply(this, arguments);
        TwoPlayerGame.begin.apply(this, arguments);

        //<<-- Creer-Merge: begin -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.players[0].color = "White";
        this.players[0].fileDirection = 1;
        this.players[1].color = "Black";
        this.players[1].fileDirection = -1;

        var backRank = {a: "Rook", b: "Knight", c: "Bishop", d: "Queen", e: "King", f: "Bishop", g: "Knight", h: "Rook"};

        for(var file = 1; file <= 8; file++) {
            var type = undefined;
            var lookupType = false;
            var owner = undefined;

            if(file === 2 || file === 7) {
                type = "Pawn";
            }
            else if(file === 1 || file === 8) {
                lookupType = true;
            }

            if(file <= 2) {
                owner = this.players[0];
            }
            else if(file >= 7) {
                owner = this.players[1];
            }

            if((type || lookupType) && owner) {
                for(var i = 0; i < 8; i++) {
                    var rank = String.fromCharCode(97 + i); // number to character, so 0 -> 'a', 1 -> 'b', etc.

                    if(lookupType) { // lookup type based on rank
                        type = backRank[rank];
                    }

                    var piece = this.create("Piece", {
                        type: type,
                        rank: rank,
                        file: file,
                        owner: owner,
                    });

                    this.pieces.push(piece);
                    piece.owner.pieces.push(piece);
                }
            }
        }

        this._generateMoves();

        //<<-- /Creer-Merge: begin -->>
    },

    /**
     * This is called when the game has started, after all the begin()s. This is a good spot to send orders.
     */
    _started: function() {
        TurnBasedGame._started.apply(this, arguments);
        TwoPlayerGame._started.apply(this, arguments);

        //<<-- Creer-Merge: _started -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        // any logic for _started can be put here
        //<<-- /Creer-Merge: _started -->>
    },


    //<<-- Creer-Merge: added-functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

    _playerStartingTime: 9e11, // 15 min in nanoseconds
    _playerAdditionalTimePerTurn: 0, // they start with 15 min and get no additional time per turn.

    _generateMoves: function() {
        this.validMoves = this.chess.moves({verbose: true});
    },

    /**
     * Looks at the chess.js instance to update this Game's GameObjects. Should be called after a move is made.
     *
     * @param {Piece} piece - the piece that moved resulting in this update
     * @param {Object} result - result object returned from chess.move
     */
    update: function(piece, result) {
        var captured;
        if(result.flags === "e") { // en passant capture
            captured = this._getPieceAt(result.to[0] + result.from[1]);
        }
        else if(result.captured) { // normal capture via moving to captured piece
            captured = this._getPieceAt(result.to);
        }

        if(captured) {
            captured.captured = true;
            captured.rank = "";
            captured.file = -1;
            this.pieces.removeElement(captured);
            captured.owner.pieces.removeElement(captured);
        }

        if(result.flags === "q" || result.flags === "k") { // queen or king side castle
            var rank = result.flags === "q" ? "a" : "h"; // queenside rook at rank "a", kingside at "h"
            var file = result.to[1];
            var rook = this._getPieceAt(rank + file);

            var rookRank = result.flags === "q" ? "d" : "f"; // queenside castle ends up at rank "d", kingside at "f"
            rook.rank = rookRank;
            rook.file = parseInt(file);
            rook.hasMoved = true;
        }

        piece.rank = result.to[0];
        piece.file = parseInt(result.to[1]);
        piece.hasMoved = true;
        this.moves.push(result.san);

        this.turnsToDraw = (piece.type === "Pawn" || captured) ? 100 : Math.max(this.turnsToDraw - 1, 0);

        if(result.promotion) {
            piece.type = ({
                n: "Knight",
                b: "Bishop",
                r: "Rook",
                q: "Queen",
            })[result.promotion.toLowerCase()];
        }

        piece.owner.madeMove = true;
        piece.owner.inCheck = false; // you can only move out of check
        piece.owner.otherPlayer.inCheck = this.chess.in_check();

        if(this.chess.in_checkmate()) {
            this.declareWinner(this.currentPlayer, "Checkmate!");
            this.declareLoser(this.currentPlayer.otherPlayer, "Checkmated");
        }
        else if(this.turnsToDraw <= 0) { // this.chess.in_draw() should be true at the same time, but we are tracking the turns anyways, and chess.in_draw() checks for more than the 50-turn rule so the checks following this one would never be reached
            this.declareLosers(this.players, "Draw - 50-move rule: 50 moves completed with no pawn moved or piece captured.");
        }
        if(this.chess.insufficient_material()) {
            this.declareLosers(this.players, "Draw - Insufficient material (K vs. K, K vs. KB, or K vs. KN) for checkmate.");
        }
        else if(this.chess.in_stalemate()) {
            this.declareLosers(this.players, "Stalemate - The side to move has been stalemated because they are not in check but have no valid moves.");
        }
        else if(this.chess.in_threefold_repetition()) {
            this.declareLosers(this.players, "Stalemate - Board position has occurred three or more times.");
        }
        else { // the game is not over
            this._generateMoves();
        }
    },

    _getPieceAt: function(pos) {
        for(var i = 0; i < this.pieces.length; i++) {
            var piece = this.pieces[i];
            if(pos === (piece.rank + piece.file)) {
                return piece;
            }
        }
    },

    nextTurn: function(/* ... */) {
        if(!this.currentPlayer.madeMove) {
            this.declareLoser(this.currentPlayer, "Did not make a move on turn number {}".format(this.currentTurn));
            this.declareWinner(this.currentPlayer.otherPlayer, "Other player did not make a move on turn number {}".format(this.currentTurn));
            return; // game over
        }

        for(var i = 0; i < this.players.length; i++) {
            this.players[i].madeMove = false;
        }

        return TurnBasedGame.nextTurn.apply(this, arguments);
    }

    //<<-- /Creer-Merge: added-functions -->>

});

module.exports = Game;
