// Generated by Creer at 04:13PM on December 01, 2015 UTC, git hash: '1b69e788060071d644dd7b8745dca107577844e1'

var Class = require(__basedir + "/utilities/class");
var serializer = require(__basedir + "/gameplay/serializer");
var log = require(__basedir + "/gameplay/log");
var TwoPlayerGame = require(__basedir + "/gameplay/shared/twoPlayerGame");
var TurnBasedGame = require(__basedir + "/gameplay/shared/turnBasedGame");

//<<-- Creer-Merge: requires -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

var Chess = require("chess.js").Chess; // a very popular chess framework we will use to run all chess logic. This Game is basically an interface to chess.js

//<<-- /Creer-Merge: requires -->>

// @class Game: The traditional 8x8 chess board with pieces.
var Game = Class(TwoPlayerGame, TurnBasedGame, {
    /**
     * Initializes Games.
     *
     * @param {Object} data - a simple mapping passsed in to the constructor with whatever you sent with it. GameSettings are in here by key/value as well.
     */
    init: function(data) {
        TurnBasedGame.init.apply(this, arguments);
        TwoPlayerGame.init.apply(this, arguments);

        /**
         *  The list of moves in standard algebraic notation (SAN).
         *
         * @type {list.<string>}
         */
        this._addProperty("moves", serializer.defaultArray(data.moves));

        /**
         * All the uncaptured pieces in the game.
         *
         * @type {list.<Piece>}
         */
        this._addProperty("pieces", serializer.defaultArray(data.pieces));

        /**
         * How many turns until the game ends because no pawn has moved and no piece has been taken
         *
         * @type {number}
         */
        this._addProperty("turnsToStalemate", serializer.defaultInteger(data.turnsToStalemate));


        //<<-- Creer-Merge: init -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.chess = new Chess();
        this.maxTurns = 6000; // longest possible game without stalemate is 5,950

        //<<-- /Creer-Merge: init -->>
    },

    name: "Chess",
    webserverID: "MegaMinerAI-2015-Chess",


    /**
     * This is called when the game begins, once players are connected and ready to play, and game objects have been initialized. Anything in init() may not have the appropriate game objects created yet..
     */
    begin: function() {
        TurnBasedGame.begin.apply(this, arguments);
        TwoPlayerGame.begin.apply(this, arguments);

        //<<-- Creer-Merge: begin -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.players[0].color = "White";
        this.players[0].fileDirection = 1;
        this.players[1].color = "Black";
        this.players[1].fileDirection = -1;

        var backRank = {a: "Rook", b: "Knight", c: "Bishop", d: "Queen", e: "King", f: "Bishop", g: "Knight", h: "Rook"};

        for(var file = 1; file <= 8; file++) {
            var type = undefined;
            var lookupType = false;
            var owner = undefined;

            if(file === 2 || file === 7) {
                type = "Pawn";
            }
            else if(file === 1 || file === 8) {
                lookupType = true;
            }

            if(file <= 2) {
                owner = this.players[0];
            }
            else if(file >= 7) {
                owner = this.players[1];
            }

            if((type || lookupType) && owner) {
                for(var i = 0; i < 8; i++) {
                    var rank = String.fromCharCode(97 + i); // number to character, so 0 -> 'a', 1 -> 'b', etc.

                    if(lookupType) { // lookup type based on rank
                        type = backRank[rank];
                    }

                    var piece = this.create("Piece", {
                        type: type,
                        rank: rank,
                        file: file,
                        owner: owner,
                    });

                    this.pieces.push(piece);
                    piece.owner.pieces.push(piece);
                }
            }
        }

        this._generateMoves();

        //<<-- /Creer-Merge: begin -->>
    },

    /**
     * This is called when the game has started, after all the begin()s. This is a good spot to send orders.
     */
    _started: function() {
        TurnBasedGame._started.apply(this, arguments);
        TwoPlayerGame._started.apply(this, arguments);

        //<<-- Creer-Merge: _started -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        // any logic for _started can be put here
        //<<-- /Creer-Merge: _started -->>
    },


    //<<-- Creer-Merge: added-functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

    _generateMoves: function() {
        this.moves = this.chess.moves({verbose: true});
    },

    /**
     * Looks at the chess.js instance to update this Game's GameObjects. Should be called after a move is made.
     *
     * @param {Piece} piece - the piece that moved resulting in this update
     * @param {Object} result - result object returned from chess.move
     */
    update: function(piece, result) {
        var captured;
        if(result.flags === "c") { // normal capture
            captured = this._getPieceAt(result.to);
        }
        else if(result.flags === "e") { // en passant capture
            captured = this._getPieceAt(result.to[0] + result.from[1]);
        }

        if(captured) {
            captured.captured = true;
            captured.rank = "";
            captured.file = -1;
            this.pieces.removeElement(captured);
            captured.owner.pieces.removeElement(captured);
        }

        if(result.flags === "q" || result.flags === "k") { // queen or king side castle
            var rank = result.flags === "q" ? "a" : "h"; // queenside rook at rank "a", kingside at "h"
            var file = result.to[1];
            var rook = this._getPieceAt(rank + file);

            var rookRank = result.flags === "q" ? "c" : "g"; // queenside castle ends up at rank "c", kingside at "g"
            rook.rank = rookRank;
            rook.file = parseInt(file);
            rook.hasMoved = true;
        }

        piece.rank = result.to[0];
        piece.file = parseInt(result.to[1]);
        piece.hasMoved = true;
        this.moves.push(result.san);

        /*if(piece.type !== "Pawn" && !captured) {
            this.turnsToStalemate--;
            if(this.turnsToStalemate <= 0) {
                this.declareLosers(this.players, "100 turns passed with no pawn advancement or captures, draw.");
            }
        }*/

        if(result.promotion) {
            piece.type = ({
                n: "Knight",
                b: "Bishop",
                r: "Rook",
                q: "Queen",
            })[result.promotion.toLowerCase()];
        }

        piece.owner.madeMove = true;
        piece.owner.inCheck = false; // you can only move out of check
        piece.owner.otherPlayer.inCheck = this.chess.in_check();

        if(this.chess.in_checkmate()) {
            this.declareWinner(this.currentPlayer, "Checkmate!");
            this.declareLoser(this.currentPlayer.otherPlayer, "Checkmated");
        }
        if(this.chess.insufficient_material()) {
            this.declareLosers(this.players, "Draw - Insufficient material (K vs. K, K vs. KB, or K vs. KN)");
        }
        else if(this.chess.in_draw()) {
            this.declareLosers(this.players, "Draw - 50-move rule");
        }
        else if(this.chess.in_stalemate()) {
            this.declareLosers(this.players, "Stalemate - The side to move has been stalemated");
        }
        else if(this.chess.in_threefold_repetition()) {
            this.declareLosers(this.players, "Stalemate - Board position has occurred three or more times");
        }

        this._generateMoves();
    },

    _getPieceAt: function(pos) {
        for(var i = 0; i < this.pieces.length; i++) {
            var piece = this.pieces[i];
            if(pos === (piece.rank + piece.file)) {
                return piece;
            }
        }
    },

    nextTurn: function(/* ... */) {
        if(!this.currentPlayer.madeMove) {
            this.declareLoser(this.currentPlayer, "Did not make a move on turn number {}".format(this.currentTurn));
            this.declareWinner(this.currentPlayer.otherPlayer, "Other player did not make a move on turn number {}".format(this.currentTurn));
            return; // game over
        }

        for(var i = 0; i < this.players.length; i++) {
            this.players[i].madeMove = false;
        }

        return TurnBasedGame.nextTurn.apply(this, arguments);
    }

    //<<-- /Creer-Merge: added-functions -->>

});

module.exports = Game;
