// Generated by Creer at 06:37PM on February 15, 2016 UTC, git hash: '955970b8006ac45cc438822363db1bc1242d9868'

var Class = require(__basedir + "/utilities/class");
var serializer = require(__basedir + "/gameplay/serializer");
var log = require(__basedir + "/gameplay/log");
var TwoPlayerGame = require(__basedir + "/gameplay/shared/twoPlayerGame");
var TurnBasedGame = require(__basedir + "/gameplay/shared/turnBasedGame");

//<<-- Creer-Merge: requires -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

var Chess = require("chess.js").Chess; // a very popular chess framework we will use to run all chess logic. This Game is basically an interface to chess.js

//<<-- /Creer-Merge: requires -->>

// @class Game: The traditional 8x8 chess board with pieces.
var Game = Class(TwoPlayerGame, TurnBasedGame, {
    /**
     * Initializes Games.
     *
     * @param {Object} data - a simple mapping passsed in to the constructor with whatever you sent with it. GameSettings are in here by key/value as well.
     */
    init: function(data) {
        TurnBasedGame.init.apply(this, arguments);
        TwoPlayerGame.init.apply(this, arguments);

        /**
         *  The list of Moves that have occured, in order.
         *
         * @type {list.<Move>}
         */
        this._addProperty("moves", serializer.defaultArray(data.moves));

        /**
         * All the uncaptured pieces in the game.
         *
         * @type {list.<Piece>}
         */
        this._addProperty("pieces", serializer.defaultArray(data.pieces));

        /**
         * How many turns until the game ends because no pawn has moved and no piece has been taken.
         *
         * @type {number}
         */
        this._addProperty("turnsToDraw", serializer.defaultInteger(data.turnsToDraw));


        //<<-- Creer-Merge: init -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.chess = new Chess();
        this.maxTurns = 6000; // longest possible known game without stalemate is 5,950
        this.turnsToDraw = 100; // 50 move rule, 50 moves are two complete turns, so 100 turns in total.

        //<<-- /Creer-Merge: init -->>
    },

    name: "Chess",
    webserverID: "MegaMinerAI-##-Chess",


    /**
     * This is called when the game begins, once players are connected and ready to play, and game objects have been initialized. Anything in init() may not have the appropriate game objects created yet..
     */
    begin: function() {
        TurnBasedGame.begin.apply(this, arguments);
        TwoPlayerGame.begin.apply(this, arguments);

        //<<-- Creer-Merge: begin -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.players[0].color = "White";
        this.players[0].rankDirection = 1;
        this.players[1].color = "Black";
        this.players[1].rankDirection = -1;

        var backFile = {a: "Rook", b: "Knight", c: "Bishop", d: "Queen", e: "King", f: "Bishop", g: "Knight", h: "Rook"};

        for(var rank = 1; rank <= 8; rank++) {
            var type = undefined;
            var lookupType = false;
            var owner = undefined;

            if(rank === 2 || rank === 7) {
                type = "Pawn";
            }
            else if(rank === 1 || rank === 8) {
                lookupType = true;
            }

            if(rank <= 2) {
                owner = this.players[0];
            }
            else if(rank >= 7) {
                owner = this.players[1];
            }

            if((type || lookupType) && owner) {
                for(var i = 0; i < 8; i++) {
                    var file = String.fromCharCode(97 + i); // number to character, so 0 -> 'a', 1 -> 'b', etc.

                    if(lookupType) { // lookup type based on file
                        type = backFile[file];
                    }

                    var piece = this.create("Piece", {
                        type: type,
                        file: file,
                        rank: rank,
                        owner: owner,
                    });

                    this.pieces.push(piece);
                    piece.owner.pieces.push(piece);
                }
            }
        }

        this._generateMoves();

        //<<-- /Creer-Merge: begin -->>
    },

    /**
     * This is called when the game has started, after all the begin()s. This is a good spot to send orders.
     */
    _started: function() {
        TurnBasedGame._started.apply(this, arguments);
        TwoPlayerGame._started.apply(this, arguments);

        //<<-- Creer-Merge: _started -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.
        // any logic for _started can be put here
        //<<-- /Creer-Merge: _started -->>
    },


    //<<-- Creer-Merge: added-functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

    _playerStartingTime: 9e11, // 15 min in nanoseconds
    _playerAdditionalTimePerTurn: 0, // they start with 15 min and get no additional time per turn.

    _generateMoves: function() {
        this.validMoves = this.chess.moves({verbose: true});
    },

    /**
     * Looks at the chess.js instance to update this Game's GameObjects. Should be called after a move is made successfully.
     *
     * @param {Piece} piece - the piece that moved resulting in this update
     * @param {Object} result - result object returned from chess.move
     * @returns {Move} the move that was made in a Move object+
     */
    update: function(piece, result) {
        var captured;
        var move = this.create("Move", {
            san: result.san,
            piece: piece,
            fromFile: piece.file,
            fromRank: piece.rank,
        });

        if(result.flags === "e") { // en passant capture
            captured = this._getPieceAt(result.to[0] + result.from[1]);
        }
        else if(result.captured) { // normal capture via moving to captured piece
            captured = this._getPieceAt(result.to);
        }

        if(captured) {
            captured.captured = true;
            captured.file = "";
            captured.rank = -1;
            this.pieces.removeElement(captured);
            captured.owner.pieces.removeElement(captured);
            move.captured = captured;
        }

        if(result.flags === "q" || result.flags === "k") { // queen or king side castle
            var file = result.flags === "q" ? "a" : "h"; // queenside rook at file "a", kingside at "h"
            var rank = result.to[1];
            var rook = this._getPieceAt(file + rank);

            var rookFile = result.flags === "q" ? "d" : "f"; // queenside castle ends up at file "d", kingside at "f"
            rook.file = rookFile;
            rook.rank = parseInt(rank);
            rook.hasMoved = true;
        }

        piece.file = result.to[0];
        piece.rank = parseInt(result.to[1]);
        piece.hasMoved = true;

        move.toFile = piece.file;
        move.toRank = piece.rank;

        this.turnsToDraw = (piece.type === "Pawn" || captured) ? 100 : Math.max(this.turnsToDraw - 1, 0);

        if(result.promotion) {
            piece.type = ({
                n: "Knight",
                b: "Bishop",
                r: "Rook",
                q: "Queen",
            })[result.promotion.toLowerCase()];

            move.promotion = piece.type;
        }

        this.moves.push(move);
        piece.owner.madeMove = true;
        piece.owner.inCheck = false; // you can only move out of check
        piece.owner.otherPlayer.inCheck = this.chess.in_check();

        if(this.chess.in_checkmate()) {
            this.declareWinner(this.currentPlayer, "Checkmate!");
            this.declareLoser(this.currentPlayer.otherPlayer, "Checkmated");
        }
        else if(this.turnsToDraw <= 0) { // this.chess.in_draw() should be true at the same time, but we are tracking the turns anyways, and chess.in_draw() checks for more than the 50-turn rule so the checks following this one would never be reached
            this.declareLosers(this.players, "Draw - 50-move rule: 50 moves completed with no pawn moved or piece captured.");
        }
        if(this.chess.insufficient_material()) {
            this.declareLosers(this.players, "Draw - Insufficient material (K vs. K, K vs. KB, or K vs. KN) for checkmate.");
        }
        else if(this.chess.in_stalemate()) {
            this.declareLosers(this.players, "Stalemate - The side to move has been stalemated because they are not in check but have no valid moves.");
        }
        // disabled for Dr. T's CS5400 class
        /*else if(this.chess.in_threefold_repetition()) {
            this.declareLosers(this.players, "Stalemate - Board position has occurred three or more times.");
        }*/
        // instead we'll use his simplified rules
        else if(this._inSimplifiedThreefoldRepetition()) {
            this.declareLosers(this.players, "Draw - Simplified threefold repetition occured.");
        }
        else { // the game is not over
            this._generateMoves();
        }

        return move;
    },

    /**
     * Gets the Piece at pos, in format "a1"
     *
     * @param {string} pos - the position, with file and rank at [0] and [1] respectively in the string.
     * @returns {Piece} the piece at pos, if found; undefined otherwise
     */
    _getPieceAt: function(pos) {
        for(var i = 0; i < this.pieces.length; i++) {
            var piece = this.pieces[i];
            if(pos.toLowerCase() === piece.file + piece.rank) {
                return piece;
            }
        }
    },

    /**
     * if for the last eight moves no capture, promotions, or pawn movement has happened and moves 0,1,2, and 3 are identical to moves 4, 5, 6, and 7 respectively, then a draw has occurred
     *
     * @returns {Boolean} true if so, false otherwise
     */
    _inSimplifiedThreefoldRepetition: function() {
        var moves = this.moves.length;

        if(moves < 8) {
            return false;
        }

        for(var i = 0; i < 4; i++) {
            var move = this.moves[moves + i - 8];
            var nextMove = this.moves[moves + i - 4];

            // if for the last eight moves a capture, promotions, or pawn movement has happened, then simplified threefold repetition has NOT occured
            if(!this._isSimplifiedThreefoldRepetitionMove(move) || !this._isSimplifiedThreefoldRepetitionMove(nextMove)) {
                return false;
            }

            // if any of the moves 0 and 4, 1 and 5, ..., 3 and 7 are NOT identical, then a draw has NOT occured
            //    Two moves are identical if the starting position (file and rank) and ending position (file and rank) of the moves are identical.
            if(move.piece !== nextMove.piece || move.fromFile + move.fromRank !== nextMove.fromFile + nextMove.fromRank || move.toFile + move.toRank !== nextMove.toFile + nextMove.toRank) {
                return false;
            }
        }

        return true; // if we got here we could not find anything about the move that would make it repetitive, so it is in Simplied Threefold Repetition
    },

    /**
     * checks if for the had move no capture, promotions, or pawn movement has happened
     *
     * @returns {Boolean} true is so, false otherwise
     */
    _isSimplifiedThreefoldRepetitionMove: function(move) {
        return Boolean(move.captured || move.promotion || move.piece.type === "Pawn");
    },

    /**
     * @override
     */
    nextTurn: function(/* ... */) {
        if(!this.currentPlayer.madeMove) {
            this.declareLoser(this.currentPlayer, "Did not make a move on turn number {}".format(this.currentTurn));
            this.declareWinner(this.currentPlayer.otherPlayer, "Other player did not make a move on turn number {}".format(this.currentTurn));
            return; // game over
        }

        for(var i = 0; i < this.players.length; i++) {
            this.players[i].madeMove = false;
        }

        return TurnBasedGame.nextTurn.apply(this, arguments);
    }

    //<<-- /Creer-Merge: added-functions -->>

});

module.exports = Game;
