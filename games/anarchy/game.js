// Generated by Creer at 10:54PM on October 16, 2015 UTC, git hash: '98604e3773d1933864742cb78acbf6ea0b4ecd7b'

var Class = require(__basedir + "/utilities/class");
var serializer = require(__basedir + "/gameplay/serializer");
var log = require(__basedir + "/gameplay/log");
var TurnBasedGame = require(__basedir + "/gameplay/shared/turnBasedGame");

//<<-- Creer-Merge: requires -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

// any additional requires you want can be required here safely between cree runs
//<<-- /Creer-Merge: requires -->>

// @class Game: Two player grid based game where each player tries to burn down the other player's buildings. Let it burn!
var Game = Class(TurnBasedGame, {
    /**
     * Initializes Games.
     *
     * @param {Object} a simple mapping passsed in to the constructor with whatever you sent with it.
     */
    init: function(data) {
        TurnBasedGame.init.apply(this, arguments);

        /**
         * How many bribes players get at the beginning of their turn, not counting their burned down Buildings.
         *
         * @type {number}
         */
        this._addProperty("baseBribesPerTurn", serializer.defaultInteger(data.baseBribesPerTurn));

        /**
         * All the buildings in the game.
         *
         * @type {list.<Building>}
         */
        this._addProperty("buildings", serializer.defaultArray(data.buildings));

        /**
         * The current Forecast, which will be applied at the end of the turn.
         *
         * @type {Forecast}
         */
        this._addProperty("currentForecast", serializer.defaultGameObject(data.currentForecast));

        /**
         * All the forecasts in the game, indexed by turn number.
         *
         * @type {list.<Forecast>}
         */
        this._addProperty("forecasts", serializer.defaultArray(data.forecasts));

        /**
         * The width of the entire map along the vertical (y) axis.
         *
         * @type {number}
         */
        this._addProperty("mapHeight", serializer.defaultInteger(data.mapHeight));

        /**
         * The width of the entire map along the horizontal (x) axis.
         *
         * @type {number}
         */
        this._addProperty("mapWidth", serializer.defaultInteger(data.mapWidth));

        /**
         * The maximum amount of fire value for any Building.
         *
         * @type {number}
         */
        this._addProperty("maxFire", serializer.defaultInteger(data.maxFire));

        /**
         * The next Forecast, which will be applied at the end of your opponent's turn. This is also the Forecast WeatherStations can control this turn.
         *
         * @type {Forecast}
         */
        this._addProperty("nextForecast", serializer.defaultGameObject(data.nextForecast));


        //<<-- Creer-Merge: init -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this.forecastIndex = 0;

        this.maxTurns = 300;
        this.mapWidth = 40;
        this.mapHeight = 20;

        this.directions = [ "north", "east", "south", "west" ]; // TODO: expose to AIs?
        this.directionalOffset = {
            north: {x: 0, y: -1},
            east: {x: 1, y: 0},
            south: {x: 0, y: 1},
            west: {x: -1, y: 0},
        };

        this.baseBribesPerTurn = 10;

        this.buildingStartingHealth = 100;
        this.headquartersStartingHealth = 1000;

        this.maxFire = 20;
        this.headquartersFireAdded = 20;
        this.warehouseFireAdded = 10;

        this.maxForecastIntensity = 10;

        //<<-- /Creer-Merge: init -->>
    },

    name: "Anarchy",
    numberOfPlayers: 2,
    maxInvalidsPerPlayer: 10,

    /**
     * This is called when the game begins, once players are connected and ready to play, and game objects have been initialized. Anything in init() may not have the appropriate game objects created yet..
     */
    begin: function() {
        TurnBasedGame.begin.apply(this, arguments);

        //<<-- Creer-Merge: begin -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

        this._buildingsGrid = [];
        var originalBuildings = [];
        var buildingTypes = ["Warehouse", "FireDepartment", "PoliceDepartment", "WeatherStation"]; // TODO: should we weigh these so some are generated more often?

        // TODO: make actual map generation algorithm that makes sure each player has a "fair" number of buildings, and the map is "interesting"
        for(var x = 0; x < this.mapWidth; x++) {
            this._buildingsGrid[x] = [];
            if(x < this.mapWidth/2) {
                for(var y = 0; y < this.mapHeight; y++) {
                    if(Math.random() > 0.5) {
                        originalBuildings.push(this._createBuilding(buildingTypes.randomElement(), {
                            x: x,
                            y: y,
                            owner: this.players.randomElement(), // TODO: random percent on each side?
                        }));
                    }
                }
            }
        }

        // TODO: yes this could break if somehow no warehouses are randomly generated. That should be fixed with a real map generation algorithm
        this.players[0].warehouses.randomElement().makeHeadquarters();

        // mirror the map
        for(var i = 0; i < originalBuildings.length; i++) {
            var originalBuilding = originalBuildings[i];
            this._createBuilding(originalBuilding.gameObjectName, {
                x: this.mapWidth - originalBuilding.x - 1,
                y: originalBuilding.y,
                owner: this.getOtherPlayers(originalBuilding.owner)[0],
                isHeadquarters: originalBuilding.isHeadquarters,
            });
        }

        // now all the buildings on the map should be created, so hook up the north/east/south/west pointers
        for(var i = 0; i < this.buildings.length; i++) {
            var building = this.buildings[i];
            for(var direction in this.directionalOffset) {
                if(this.directionalOffset.hasOwnProperty(direction)) {
                    var offset = this.directionalOffset[direction];
                    building["building" + direction.upcaseFirst()] = this._getBuildingAt(building.x + offset.x, building.y + offset.y);
                }
            }
            log("building:", building.gameObjectName, building.x, building.y, building.health);
            if(building.isHeadquarters) {
                log("-->", building.health, building.owner.headquarters);
            }
        }

        // create the forecasts, each "set" of turns (e.g. 0 and 1, 100 and 101, 264 and 265, etc) are the same initial states for each player.
        for(var i = 0; i < this.maxTurns; i += 2) {
            var direction = this.directions.randomElement();
            var intensity = Math.randomInt(0, this.maxForecastIntensity);

            for(var j = 0; j < 2; j++) {
                this.forecasts.push(this.create("Forecast", {
                    direction: direction,
                    intensity: intensity,
                    controllingPlayer: this.players[j],
                }));
            }
        }
        this.currentForecast = this.forecasts[0];
        this.nextForecast = this.forecasts[1];

        //<<-- /Creer-Merge: begin -->>
    },

    //<<-- Creer-Merge: added-functions -->> - Code you add between this comment and the end comment will be preserved between Creer re-runs.

   _maxTurnsReached: function(){TurnBasedGame._maxTurnsReached.apply(this, arguments);
        TurnBasedGame._maxTurnsReached.apply(this, arguments);

        for(var i = 0; i < this.players.length; i++) {
            var player = this.players[i];

            if(player.headquarters.health < this.getOtherPlayers(player)[0]) {
                game.declareLoser(player, "Your Headquarters has less health than the opponents.");
                game.declareWinner(this.getOtherPlayers(player)[0], "You did more damage to the other player's Headquarters.");
            }
        }
   },
    // You can add additional functions here. These functions will not be directly callable by client AIs

    //This function will deal with the next turn logic and win conditons
    nextTurn: function() {
        for(var i = 0; i < this.players.length; i++) {
            var player = this.players[i];
            player.bribesRemaining = this.baseBribesPerTurn + player.burnedBuildings;
        }

       var directions = {
            north: "buildingNorth",
            east: "buildingEast",
            south: "buildingSouth",
            west: "buildingWest"
        };

        //locations where fire will spread
        var locations = [];

        for(var i = 0; i < this.buildings.length; i++){
            var building = this.buildings[i];
            if(building.fire > 0){
                var previousHP = building.health;
                building.burn()

                //make sure building wasnt already dead
                if(previousHP > 0 && building.health <= 0){
                    var player = building.owner;
                    player.burnedBuildings++;
                    if(building.isHeadquarters) {
                        game.declareLoser(player, "Your Headquarters burned down!");
                        game.declareWinner(this.getOtherPlayers(player)[0], "You burned down the other players Headquarters.");                        
                    }
                }

                //location the fire will spread to
                var location = building[directions[this.currentForecast.direction]];
                locations.push({
                    building: location,
                    fire: building.fire
                });
            }

            if(building.exposure && !building.bribed){
                building.exposure -= 1; //this.exposureCooldown?
            }

            building.bribed = false;
        }

        //spread fire
        for(var i = 0; i < locations.length; i++){
            var location = locations[i];
            var building = location.building;
            var fireSpread = this.currentForecast.intensity;
            if(fireSpread < building.fire){
                fireSpread = building.fire;
            }

            var newFire = building.fire + fireSpread;
            building.fire = Math.min(this.maxFire, newFire);
        }

        this.currentForecast = this.forecasts[this.forecastIndex++];

        return TurnBasedGame.nextTurn.apply(this, arguments);
    },

    /**
     * creates a Building of the class type, and adds it to the necessary lists.
     *
     * @param {string} buildingType - the class name of the Building sub class
     * @param {object} data - initialization data for new building. Must have an owner set
     * @returns {Building} the newly created and hooked up building
     */
    _createBuilding: function(buildingType, data) {
        var newBuilding = this.create(buildingType, data);

        this._buildingsGrid[newBuilding.x][newBuilding.y] = newBuilding;
        this.buildings.push(newBuilding);
        newBuilding.owner[buildingType.lowercaseFirst() + "s"].push(newBuilding); // adds the new building to it's owner list of that building type

        return newBuilding;
    },

    /**
     * tries to get the building at a given (x, y), or null if there is none. O(1) lookup time
     *
     * @param {number} x - x position
     * @param {number} y - y position
     * @returns {Building|null} the building at (x, y) if there is one, null otherwise
     */
    _getBuildingAt: function(x, y) {
        if(x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight) {
            return this._buildingsGrid[x][y] || null;
        }

        return null;
    },

    //<<-- /Creer-Merge: added-functions -->>

});

module.exports = Game;
